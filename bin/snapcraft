#!/usr/bin/python3
# -*- Mode:Python; indent-tabs-mode:t; tab-width:4 -*-

import glob
import os
import subprocess
import sys
import tempfile
import time
import yaml

sys.path.append(os.path.abspath(os.path.join(__file__, "..", "..")))
import snapcraft
import snapcraft.common
import snapcraft.plugin

packagesToInstall = []
allParts = []
afterRequests = {}

def loadPlugin(partName, pluginName, properties, loadCode=True):
	global allParts, packagesToInstall

	pluginDir = os.path.abspath(os.path.join(__file__, "..", "..", "plugins"))

	part = snapcraft.plugin.Plugin(pluginDir, pluginName, partName, properties, loadCode=loadCode)
	if not part.isValid():
		snapcraft.common.log("Could not load part %s" % pluginName, file=sys.stderr)
		sys.exit(1)

	packagesToInstall += part.config.get('systemPackages', [])
	allParts.append(part)
	return part

cmds = sys.argv[1:]
if not cmds:
	snapcraft.common.log("Need an argument", file=sys.stderr)
	sys.exit(1)

forceAll = False
forceCommand = None
if "--force" in cmds:
	cmds.remove("--force")
	forceAll = True

if cmds[0] == "all":
	cmds = snapcraft.common.commandOrder
else:
	if cmds[0] in snapcraft.common.commandOrder:
			forceCommand = cmds[0]
			cmds = snapcraft.common.commandOrder[0:snapcraft.common.commandOrder.index(cmds[0])+1]

if cmds[0] == "init":
	if os.path.exists("craft.yaml"):
		snapcraft.common.log("craft.yaml already exists!", file=sys.stderr)
		sys.exit(1)
	yaml = 'parts:\n'
	for partName in cmds[1:]:
		loadPlugin(partName, partName, {}, loadCode=False)
	for part in allParts:
		yaml += '    ' + part.names()[0] + ':\n'
		for opt in part.config.get('options', []):
			if part.config['options'][opt].get('required', False):
				yaml += '        ' + opt + ':\n'
	yaml = yaml.strip()
	with open('craft.yaml', mode='w+') as f:
		f.write(yaml)
	snapcraft.common.log("Wrote the following as craft.yaml.")
	print()
	print(yaml)
	sys.exit(0)				

data = yaml.load(open("craft.yaml", 'r'))
packagesToInstall = data.get('systemPackages', [])

for partName in data["parts"]:
	properties = data["parts"][partName]

	pluginName = properties.get("plugin", partName)
	if "plugin" in properties: del properties["plugin"]

	if "after" in properties:
		afterRequests[partName] = properties["after"]
		del properties["after"]

	loadPlugin(partName, pluginName, properties)

# Grab all required dependencies, if not already specified
newParts = allParts.copy()
while newParts:
	part = newParts.pop(0)
	requires = part.config.get('requires', [])
	for requiredPart in requires:
		alreadyPresent = False
		for p in allParts:
			if requiredPart in p.names():
				alreadyPresent = True
				break
		if not alreadyPresent:
			newParts.append(loadPlugin(requiredPart, requiredPart, {}))

# Now sort them
partsToSort = allParts.copy()
while partsToSort:
	part = partsToSort.pop(0)
	requires = part.config.get('requires', [])
	for requiredPart in requires:
		for i in range(len(allParts)):
			if requiredPart in allParts[i].names():
				allParts.insert(0, allParts.pop(i))
				break
	afterNames = afterRequests.get(part.names()[0], [])
	for afterName in afterNames:
		for i in range(len(allParts)):
			if afterName in allParts[i].names():
				allParts.insert(0, allParts.pop(i))
				break

# Install local packages that we need
if packagesToInstall:
	newPackages = []
	for checkpkg in packagesToInstall:
		if subprocess.call(['dpkg-query', '-s', checkpkg], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) != 0:
			newPackages.append(checkpkg)
	if newPackages:
		print("Installing required packages on the host system: " + ", ".join(newPackages))
		subprocess.call(['sudo', 'apt-get', 'install'] + newPackages, stdout=subprocess.DEVNULL)

stagedir = os.path.join(os.getcwd(), "staging")
snapdir = os.path.join(os.getcwd(), "snap")

env = []
env.append("PATH=\"%s/bin:$PATH\"" % stagedir)
env.append("LD_LIBRARY_PATH=\"%s/lib:$LD_LIBRARY_PATH\"" % stagedir)
env.append("CFLAGS=\"-I%s/include $CFLAGS\"" % stagedir)
env.append("LDFLAGS=\"-L%s/lib $LDFLAGS\"" % stagedir)

if cmds[0] == "shell":
	for part in allParts:
		env += part.env()
	snapcraft.common.env = env
	userCommand = ' '.join(cmds[1:])
	if not userCommand:
		userCommand = "/usr/bin/env PS1='\[\e[1;32m\]snapcraft:\w\$\[\e[0m\] ' /bin/bash --norc"
	snapcraft.common.run(userCommand)

elif cmds[0] == "assemble":
		snapcraft.common.run(
				"cp -arv %s %s" % (data["snap"]["meta"], snapdir))
		snapcraft.common.run("snappy build", cwd=snapdir)


elif cmds[0] == "run":
		qemudir = os.path.join(os.getcwd(), "image")
		qemu_img = os.path.join(qemudir, "15.04.img")
		if not os.path.exists(qemu_img):
				try: os.makedirs(qemudir)
				except FileExistsError: pass
				snapcraft.common.run(
						"sudo ubuntu-device-flash core --developer-mode --enable-ssh 15.04 -o %s" % qemu_img,
						cwd=qemudir)
		qemu = subprocess.Popen(
				["kvm", "-m", "768", "-nographic",
				 "-snapshot", "-redir", "tcp:8022::22", qemu_img],
				stdin=subprocess.PIPE)
		n = tempfile.NamedTemporaryFile()
		ssh_opts = [
				"-oStrictHostKeyChecking=no",
				"-oUserKnownHostsFile=%s" % n.name
		]
		while True:
				ret_code =subprocess.call(
						["ssh"]+ssh_opts+
						["ubuntu@localhost", "-p", "8022", "true"])
				if ret_code == 0:
						break
				print("Waiting for device")
				time.sleep(1)
		snap_dir = os.path.join(os.getcwd(), "snap")
		# copy the snap
		snaps = glob.glob(snap_dir+"/*.snap")
		subprocess.call(
				["scp"]+ssh_opts+[
						"-P", "8022", "-r"]+snaps+["ubuntu@localhost:~/"])
		# install the snap
		ret_code =subprocess.call(
				["ssh"]+ssh_opts+
				["ubuntu@localhost", "-p", "8022", "sudo snappy install  *.snap"])
		# "login"
		subprocess.call(
				["ssh"]+ssh_opts+["-p", "8022", "ubuntu@localhost"],
				preexec_fn=os.setsid)
		qemu.kill()
else:
	for part in allParts:
		env += part.env()
		snapcraft.common.env = env
		for cmd in cmds:
			force = forceAll or cmd == forceCommand
			if not getattr(part, cmd)(force=force):
				snapcraft.common.log("Failed doing %s for %s!" % (cmd, part.names()[0]))
				sys.exit(1)

